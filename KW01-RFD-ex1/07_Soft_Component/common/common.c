

#include "common.h"

static  uint_32  int_disable_level; // 当前中断嵌套层数

//=========================================================================
//函数名称：init_critical
//参数说明：无
//函数返回：无
//功能概要：初始化临界区访问控制
//=========================================================================
void  init_critical(void) 
{
    ENABLE_INTERRUPTS;
    int_disable_level = 0;
}

//=========================================================================
//函数名称：enter_critical
//参数说明：无
//函数返回：无
//功能概要：进入临界区
//=========================================================================
void  enter_critical(void)
{
    if (0 == int_disable_level)
    {
        DISABLE_INTERRUPTS;
    }
    int_disable_level++;
}

//=========================================================================
//函数名称：exit_critical
//参数说明：无
//函数返回：无
//功能概要：离开临界区
//=========================================================================
void  exit_critical(void) 
{
    if (int_disable_level)
{
        int_disable_level--;
        if (0 == int_disable_level)
        {
            ENABLE_INTERRUPTS;
        }
    }
}

//============================================================================
//函数名称：enable_irq
//函数返回：无  
//参数说明：irq：irq号
//功能概要：使能irq中断 
//============================================================================
void enable_irq (uint_16 irq)
{
    //确定irq号为有效的irq号
    if (irq > 32)	irq=32;
    //Re-enable PORTC and PORTD interrupts      //Same interrupt vector for PORTC and PORTD
    NVIC_ICPR |= (1<<(irq%32));
    NVIC_ISER |= (1<<(irq%32));

}

//============================================================================
//函数名称：disable_irq
//函数返回：无      
//参数说明：irq：irq号
//功能概要：禁止irq中断 
//============================================================================
void disable_irq (uint_16 irq)
{

    //确定irq号为有效的irq号
    if (irq > 32)	irq=32;
    
    NVIC_ICER = (1<<(irq%32));     
}
 
//============================================================================
//函数名称：set_irq_priority
//函数返回：无      
//参数说明：irq：irq号         											   
//         prio：优先级
//功能概要：设置irq中断和优先级 
//============================================================================
void set_irq_priority (uint_16 irq, uint_16 prio)
{   
    uint_8 *prio_reg;
    uint_8 err = 0;
    uint_8 div = 0;
   
    if (irq > 32)
    {    
        err = 1;
    }
    if (prio > 3)
    {     
        err = 1;
    }
    if (err != 1)
    {  
       div = irq / 4;
       prio_reg = (uint_8 *)((uint_32)&NVIC_IP(div));
       *prio_reg = ( (prio&0x3) << (8 - ARM_INTERRUPT_LEVEL_BITS) );             
    }
}

//============================================================================
//函数名称：IntRestoreAll
//函数返回：无      
//参数说明：var：中断信号         	
//功能概要：恢复所有中断
//============================================================================
void IntRestoreAll(uint32_t var)
{ 
	//PRIMASK（优先级中断屏蔽寄存器）为特殊寄存器
    asm(" MSR PRIMASK, %0" : : "r" (var));//读取var中的值，并写入PRIMASK
    asm(" CPSIE i");
}

//============================================================================
//函数名称：IntDisableAll
//函数返回：var：当前  PRIMASK寄存器的值
//参数说明：无      	
//功能概要：屏蔽所有中断
//============================================================================
uint32_t IntDisableAll(void)
{
	uint32_t var;
	//PRIMASK=1:屏蔽所有可配置优先级的异常；=0：无影响
	asm("MRS  %0, PRIMASK" : "=r" (var));//读取PRIMASK寄存器的值，并写入R0，并输出到var中
	asm(" CPSID i");
	
	return var;
}

//============================================================================
//函数名称：Delay_us
//函数返回：无
//参数说明：无      	
//功能概要：延时 - 微秒级
//============================================================================
void Delay_us(uint16_t u16us) 
{
  uint32_t u32ctr;                                          
  for(u32ctr = 0; u32ctr < ((48000 / 1000 / 11) * u16us); u32ctr++)
  {
    asm ("NOP");   
  }      
}
//============================================================================
//函数名称：Delay_us
//函数返回：无
//参数说明：无      	
//功能概要：延时 - 毫秒级
//============================================================================
void Delay_ms(uint16_t u16ms) 
{                            
  //@AC 1ms  
  //gSystemClock_d is given in KHz --> gSystemClock_d * 1000 /1000 = counts to have 1ms
  uint32_t u32ctr;
  for(u32ctr = 0; u32ctr < ((48000 / 10)*u16ms); u32ctr++)
  {
    asm ("NOP"); 
  }    
}
//============================================================================
//函数名称：Wait_6_BitClks
//函数返回：无
//参数说明：无      	
//功能概要：延时 - 6比特位持续时间
//============================================================================
void Wait_6_BitClks(void) // 持续时间 : BRA/BSR/JSR to here: 3/5/6 mcuCycles    
{                         //         2xNOP+RTS          :     8 mcuCycles
  asm ("nop");
  asm ("nop");
}

//============================================================================
//函数名称：ftochar
//函数返回：无
//参数说明：f:所要转换的浮点数        c[]:用来保存转换后的字符串
//功能概要：将浮点数转换为字符串（保留一位小数）
//============================================================================
void ftochar(float f,uint_8 c[])
{
	uint_16 p,q,i,j,a[5]={0},b[5]={0};
	p=(uint_16)f;//整数部分
	q=(f-p)*10+0.5;//小数部分（保留一位小数，四舍五入）
	i=0;
	if(0==p)//整数部分为0
		c[i++]='0';
	else//整数部分不为0
	{
		j=0;
		while(p!=0)//倒序的数字
		{
			a[j++]=p%10;
			p/=10;
		}
		while(j>0)//将倒序数字转为正序，并转换为对应的字符形式
		{
			c[i++]=a[j-1]+'0';
			--j;
		}
	}
	c[i++]='.';//小数点
	if(0==q)//小数部分为0
		c[i++]='0';
	else//小数部分不为0
	{
		j=0;
		while(q!=0)//倒序的数字
		{
			b[j++]=q%10;
			q/=10;
		}
		while(j>0)//将倒序数字转为正序，并转换为对应的字符形式
		{
			c[i++]=b[j-1]+'0';
			--j;
		}
	}
	c[i]='\0';
}



